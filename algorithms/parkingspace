
def visualize(robot, setp):
    if setp.ndim == 1:
        n_frames = 1
        setp = np.array([setp])
    else:
        n_frames = setp.shape[0]

    fig = plt.figure("config")

    # color:   blue       green      fuchsia
    colors = ('b', 'g', 'r')

    ax = fig.add_subplot(111, projection='3d')
    ax.auto_scale_xyz([-0.75, 0.75], [-0.75, 0.75], [-1.5, 0])
    ax.set_aspect("equal")

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

    circle_points = np.linspace(0, 2 * np.pi, num=100, endpoint=True)
    base_radius = robot.base_radius

    base_coord = np.column_stack((base_radius * np.cos(circle_points),
                                  base_radius * np.sin(circle_points),
                                  np.full(100, 0)))

    platform_radius = robot.platform_radius

    base, = ax.plot([], [], [], '-', color='k')
    platform, = ax.plot([], [], [], '-', color='k')
    upper_arm = sum([ax.plot([], [], [], '-', color=c) for c in colors], [])
    prlgram1 = sum([ax.plot([], [], [], '-', color=c) for c in colors], [])
    prlgram2 = sum([ax.plot([], [], [], '-', color=c) for c in colors], [])

    def init():

        base.set_data([], [])
        base.set_3d_properties([])

        platform.set_data([], [])
        platform.set_3d_properties([])

        for i in range(len(upper_arm)):
            upper_arm[i].set_data([], [])
            upper_arm[i].set_3d_properties([])

        for i in range(len(prlgram1)):
            prlgram1[i].set_data([], [])
            prlgram1[i].set_3d_properties([])

            prlgram2[i].set_data([], [])
            prlgram2[i].set_3d_properties([])

        return [base] + [platform] + upper_arm + prlgram1 + prlgram2

    def animate(i):

        robot.xyz = setp[i, ]

        base.set_data(base_coord[:, 0], base_coord[:, 1])
        base.set_3d_properties(base_coord[:, 2])

        platform_coord = np.column_stack((platform_radius * np.cos(circle_points),
                                          platform_radius * np.sin(circle_points),
                                          np.full(100, setp[i, 2])))

        platform.set_data(platform_coord[:, 0] + setp[i, 0], platform_coord[:, 1] + setp[i, 1])
        platform.set_3d_properties(platform_coord[:, 2])

        for i in range(len(upper_arm)):
            upper_arm_coord = robot.upper_arm_coord(i)
            upper_arm[i].set_data(upper_arm_coord[:, 0], upper_arm_coord[:, 1])
            upper_arm[i].set_3d_properties(upper_arm_coord[:, 2])

        for i in range(len(prlgram1)):
            prlgram_coord = robot.prlgram_arm_coord(i)

            prlgram1[i].set_data(prlgram_coord[0:2, 0], prlgram_coord[0:2, 1])
            prlgram1[i].set_3d_properties(prlgram_coord[0:2, 2])

            prlgram2[i].set_data(prlgram_coord[2:4, 0], prlgram_coord[2:4, 1])
            prlgram2[i].set_3d_properties(prlgram_coord[2:4, 2])

        return [base] + [platform] + upper_arm + prlgram1 + prlgram2

    if n_frames == 1:
        animate(0)
    else:
        ani = animation.FuncAnimation(fig, animate, frames=n_frames, blit=True, init_func=init, interval=50,
                                      repeat=True)

    plt.show()


rbot = Robot(0.164, 0.044, 0.524, 1.244, pw=0.131)

steps = np.linspace(0, 2 * np.pi, num=50, endpoint=False)

setpoint = np.column_stack((0.3 * np.cos(steps),
                            0.3 * np.sin(steps),
                            0.1 * np.sin(2 * steps) - 1.1))

visualize(rbot, setpoint)


########################

import numpy as np

SQ3 = np.sqrt(3)
d2r = np.pi / 180.0
r2d = 1.0 / d2r


def minangle(t):
    # returns minimal angle in complex vector t
    absmin_angle = t[np.argmin(np.abs(t))]
    return absmin_angle


def solve_ipk(e, f, g):
    # solves "ipk" equation
    roots = 2 * np.arctan(np.roots([g - e, 2 * f, g + e]))
    return roots


def p2c(th, r):
    # converts polar to carthesian coordinates
    return np.array([r * np.cos(th), r * np.sin(th)])


def sphere_intersect(c1, c2, c3, r):
    # sphere intersect algorithm, two options,
    # center of spheres at the same height:
    if c1[2] == c2[2] == c3[2]:
        a = 2*(c3[0] - c1[0])
        b = 2*(c3[1] - c1[1])
        c = r[0]**2 - r[2]**2 - c1[0]**2 - c1[1]**2 + c3[0]**2 + c3[1]**2
        d = 2*(c3[0] - c2[0])
        e = 2*(c3[1] - c2[1])
        f = r[1]**2 - r[2]**2 - c2[0]**2 - c2[1]**2 + c3[0]**2 + c3[1]**2

        t1 = (a*e - b*d)

        x = (c*e - b*f) / t1
        y = (a*f - c*d) / t1

        da = 1
        db = -2*c1[2]
        dc = c1[2]**2 - r[0]**2 + (x - c1[0])**2 + (y - c1[1])**2

        z = np.roots([da, db, dc])

        return np.array((x, x)), np.array((y, y)), z

    # center of spheres at the different height:
    else:
        d31 = c3 - c1
        d32 = c3 - c2

        n1 = np.dot(c1, c1)
        n2 = np.dot(c2, c2)
        n3 = np.dot(c3, c3)

        q = r[0]**2 - r[2]**2 - n1 + n3
        p = r[1]**2 - r[2]**2 - n2 + n3

        t1 = d31[0]*d32[2] - d31[2]*d32[0]
        t2 = 2*d32[2]

        a4 = (d31[2]*d32[1] - d31[1]*d32[2]) / t1
        a5 = -(d31[2]*p - d32[2]*q) / (2*t1)
        a6 = (-2*d32[0]*a4 - 2*d32[1]) / t2
        a7 = (p - 2*d32[0]*a5) / t2

        a = a4**2 + 1 + a6**2
        b = 2*a4*(a5 - c1[0]) - 2*c1[1] + 2*a6*(a7 - c1[2])
        c = a5*(a5 - 2*c1[0]) + a7*(a7 - 2*c1[2]) + n1 - r[0]**2

        y = np.roots([a, b, c])
        x = a4*y+a5
        z = a6*y+a7

        return x, y, z


##############################


    def act_coord(self, n):
        return np.append(ch.p2c(self.arm_attach[n], self.base_radius), [0])

    def shoulder_hinge_coord(self, n):
        ludx, ludy = ch.p2c(self._theta[n], self.upper_arm_length)
        return np.append(ch.p2c(self.arm_attach[n], self.base_radius + ludx), [ludy])

    def platform_hinge_coord(self, n):
        return np.append(ch.p2c(self.arm_attach[n], self.platform_radius) + self._xyz[0:2], self._xyz[2])

    def upper_arm_coord(self, n):
        base_coord = self.act_coord(n)
        hinge_coord = self.shoulder_hinge_coord(n)

        return np.vstack((base_coord, hinge_coord))

    def lower_arm_coord(self, n):
        shoulder_hinge_coord = self.shoulder_hinge_coord(n)
        platform_hinge_coord = self.platform_hinge_coord(n)

        return np.vstack((shoulder_hinge_coord, platform_hinge_coord))

    def prlgram_arm_coord(self, n):
        v1 = ch.p2c(self.arm_attach[n] + np.pi / 2, self.pgram_width / 2)
        v2 = ch.p2c(self.arm_attach[n] - np.pi / 2, self.pgram_width / 2)

        lower_arm_coord = self.lower_arm_coord(n)

        prlgram1 = np.copy(lower_arm_coord)
        prlgram2 = np.copy(lower_arm_coord)

        prlgram1[:, 0:2] += np.vstack((v1, v1))
        prlgram2[:, 0:2] += np.vstack((v2, v2))

        return np.vstack((prlgram1, prlgram2))